<h2>问题介绍</h2>
给定一个长方体车厢Container，其长宽高分别是
$L,W,H$
, 体积为
$V$
；共有
$n$
个箱子集合cargos，箱子也为长方体，第$i$个箱子的长宽高为
$l_i,w_i,h_i$
（$n$个箱子的体积总和是远远大于车厢的体积），
每个箱子体积为$v_i=l_iw_ih_i$, 定义车厢内所有箱子的体积之和为：

$$V_s = \sum_{cargo_i\in S}v_i$$

问题的目标是选择集合cargos的一个子集$S$，使得$V_s$最大，且满足以下条件和假设：

- 从$n$个箱子中选择$m$个箱子，并实现$m$个箱子在车厢中的摆放；
- 箱子必须完全包含在容器内；
- 任意两个货物内的任意一点不可在空间中的同一位置；
- 需要考虑装箱的顺序，达到尽量优解；
- 箱子各个面都可以朝下放置，没有上下左右前后的区别。

我们输入车厢的长宽高数据和货物的数量及各自的长宽高数据，输出示意图和利用率：

$$\eta=\frac{V_s}{V}$$

<h2>算法介绍</h2>
<h3>1. 初步</h3>
假设给定的箱子序列是$(b_1,b_2,...,b_n)$, 首先第一个箱子的可放置点是$(0,0,0)$,
若第一个箱子可以放入点$(0,0,0)$，则第2个箱子的可放置点有3个，分别为
$(l_1,0,0)$,$(0,w_1,0)$,$(0,0,h_1)$，假设第2个箱子选择了点$(l_1,0,0)$，
则我们删除点$(l_1,0,0)$，同时增加点$(l_1+l_2,0,0)$,$(l_1,w_2,0)$,$(l_1,0,h_2)$,
即第3个箱子的可放置点有5个。考虑第$i$个箱子，若其选择了点$(x,y,z)$,则我们先从
可放置点中删除点(x,y,z)，再增加$(x+l_i,y,z),(z,y+w_i,z),(x,y,z+h_1)$，
如下图黑圆点所示，若所有可放置点都不能放入第i个箱子，则可放置点不更新，直接考虑第$i+1$个箱子。

我们考虑两条参考线形成的参考面，$z$轴上的参考线$L_z$和$x$轴上的$L_x$.我们的放置策略是：
按顺序考虑箱子，在考虑箱子$b_i$时，先把可放置点按$y$坐标从小到大排序，$y$坐标相同的按$x$
坐标从小到大排序，$x,y$坐标都相同的按$z$坐标从小到大排序，按照排好序的可放位置去检测$b_i$
能否放入该位置。在评判箱子b_i能否放入位置(x,y,z)中时，不仅要求其不能与车厢和其他箱子相交，
而且要求$z+h_i\leq L_z, x+l_i\leq L_x$.在检测一个可放位置位置时，我们尝试所有可放置方向，
当找到第1个可放入点时，则把箱子$b_i$放入该位置，并更新可放置点。若所有可放置点都不能放入
该箱子，则分一下两种情况考虑：（1）若$L_x<L$,则提高$x$轴上的参考线，即把该箱子作为水平
方向参考箱子；（2）否则，提高$z$轴上的参考线。如果提高参考线后，该箱子还是不能放下，
这在此装填中，该箱子不能放入容器中，在以后的装填中将不再考虑该箱子。
- 与其他箱子的碰撞检测：直接在三维空间中确定两个实体是否冲突有些困难。于是，在这里，我们采用的
方法是在二维平面上考虑三维空间中的实体投影，在$xy$面、$xz$面和$yz$面上的投影情况判断是否冲突。
任意平行于长方形车厢放置的长方体货物，如果它们在任意三个方向上的投影没有重叠，则两者就没有冲突。
而对于平面上的长方体而言，相对在左边的长方体的右上角坐标如果小于相对右边的长方体的左下角坐标，
则两个长方形没有重叠。碰撞思想的检测在模块`_is_cargos_collide()`中体现，判断长方形是否冲突在`_is_rectangles_overlap()`；
- 伪代码的内循环体现在 `_encase()`与`_extend_points()`里；外训练在文件`__init__.py`中掌控程序。


**伪代码**：

$I$代表可放置点列表.

```Python
初始化 容器;初始化 货物列表;
I = [(0,0,0)]，Lx = Lz = 0;
while i = 1 until n{
    flag = 未放置未更新;
    for (x,y,z) in I{
        if (bi可以放置在可放置点 并且x+li<=Lx,z+hi<=Lz){
            flag = 已放置;
            退出 可放置点 循环;}
    }
    if (flag 标记有 未放置){
        if (Lx == 0 或者 Lx == L){
            if (bi可以放入位置(0,0,Lz)){
                将bi放置在(0,0,Lz);
                x = 0, y = 0, Lz = Lz+hi, Lx = li
                flag = 已放置已更新;}
            else if (Lz < H){
                Lz = H, Lx = H;
                flag = 未放置已更新;}
        }else{
            for (x,y,z) in I{
                if (bi可以放置在(x,y,z) 并且z+hi<=Lz){
                    Lx=Lx+li;
                    flag = 已放置已更新;
                    退出 可放置点 循环;}
            }
            if (flag 标记有 未放置){
                Lx = H;
                flag = 未放置已更新;}
        }
    }
    if (flag 标记有 已放置){
        把bi放入位置(x,y,z), I=I/{(x,y,z)};
        I新增三个点可放置点;
        i++;
    }else if(flag 标记为 未放置已更新){
        i--;
    }else if(flag 标记为 未放置未更新){
        i++;
    }
}

```

### 2. 改进（退火算法）

之前的顺序是死板的按照箱子体积从大到小摆放的，但我们知道箱子的装填顺序对效果影响很大，因此我们考虑加入了模拟退火算法来改变箱子的摆放顺序。
这里我们将领域定为随机选取两类箱子的装填顺序。因为我们的目标是使装入车厢的箱子总体积最大，因此在生成初解时，考虑贪心策略，
先把箱子体积从大到小的顺序排列。根据模拟退火的特性，我们动态增加邻域的大小。记初始温度为$S_t$，结束温度为$E_t$，温度下降率为
$d_t$,邻域初始大小为$L$，温度下降一次时增加邻域大小为$d_L$。设初始输入箱子集合为$B$，用$f$来记录当前的填充率，用$f_{best}$
记录当前最高的填充率，$B_{best}$记录最高填充率时对应的顺序，用$t$表示当前温度，$L_t$表示当前邻域长度。在实验中，我们使用了二次退火来保证解的稳定性。

**伪代码**：

```Python
将箱子体积从大到小顺序排序
f = fbest = encase_cargos_into_container(cargo)
Bbest = B
for i = 1 to 2{
    t = St, Lt = L;
    while (t >= Et):
        for j in range(1, Lt){
             随机调换两个箱子顺序,得到B1；
             f1 = encase_cargos_into_container(cargo)；
             df = f' - f；}
             if (df > 0){
                  f = f1, B = B1；
                  if(f > fbest){
                       fbest = f, Bbest = B}
                  else{
                      随机生成一个(0,1)之间的数x；
                      if (x < exp(10*df/t)){
                           f = f1, B = B1}
         Lt += dL, t *= dt

```

但此算法有个问题是时间消耗巨大，在初步算法中，平均只需要花费20s时间，而加入退火算法后，时间长达几小时。

### 3. 失败案例（放置面）

因为不同箱子有六个不同的放置面，根据现实经验，放置一定数量的箱子后，每放入一个箱子，若这个箱子与已放置的箱子
重叠面面积越大（也就是此箱子与已放置箱子越紧贴），则装箱效果理应越好，如下图所示，图二a的摆放方式应比图二b的
摆放方式更合理。受此启发，我们在程序中引入了此算法。

假定此次放入第$i$个箱子，$b_i$，计算它与已放置箱子的重叠面积，可以转化为它与相邻箱子在$xy$平面、$xz$平面和$yz$
平面的投影重叠面积，投影重叠面积越大，说明它与已放置箱子贴的越紧密。而$b_i$与相邻箱子的投影重叠面积又可以近似于
此箱子与紧贴三个坐标平面的箱子的重叠面积，于是，我们存储了所有紧贴三个坐标平面的箱子，创建`rectangles_overlap_area()`
来计算$b_i$与那些箱子的重叠面积，在每放入一个箱子，计算其各个放置方向与那些箱子的重叠面积大小，再取最大的那个姿势放入。

但是结果却不尽人意，不管是装箱全程都使用此算法进行放置，还是先采用此算法放置后同方向放置（即采用同长宽高、同放置面），
抑或是先同方向放置再采用此方法放置，都使装箱率有所下降。对于一直采用此算法放置或者先采用此算法放置后随机放置，
由于一开始箱子放置少，这样刻意地放置，可能使得很多箱子的放置方向不一致，导致箱子间的间隙增多，不如一直采用一种放
置方式，整齐划一排列；而先同方向放置再采用此方法放置，由于算法比较粗糙，放置多个箱子后，$xy$平面、$xz$平面和$yz$
平面基本都已经被已放置箱子紧贴了，所以此时计算待放置箱子与这三个面的阴影面积重合时，各个放置方向的重合面积几乎一致
不变，这也是为什么这个方法与未加此算法跑出来的结果差不多。

## 实验与运行结果

### 1. 代码结构

所有算法的实现将组织在一个名为*算法设计*的包中。该包分为四个模块：`__init__`、`_cargo`、`_container`和`drawer`。

- `__init__`：用于初始化包并组织算法代码和可变策略类；
- `_cargo`：组织箱子的代码；
- `_container`：关于容器的相关类代码；
- `drawer`：组织绘制3D效果图的相关函数代码。

### 2. 结果评估

下图是装箱结果示意图：
